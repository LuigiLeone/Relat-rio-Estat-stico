# -*- coding: utf-8 -*-
"""GymRelatorio

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1svKzqjmNMl2eZEOztJc22P2JP3ioUFSV
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import Ridge, Lasso, ElasticNet, LogisticRegression, LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, confusion_matrix

# --- Carregar o dataset ---
# Substitua o caminho pelo local do seu dataset
data = pd.read_csv("gym.csv")

# --- Tratamento de Dados ---
# Verificar valores ausentes
missing_data = data.isnull().sum()
print("Valores ausentes:\n", missing_data)

# Converter variáveis categóricas
data = pd.get_dummies(data, columns=['Gender', 'Workout_Type'], drop_first=False)

print(data.describe())

# Função para converter horas decimais em formato de horas e minutos
def format_hours(hours):
    h = int(hours)
    m = int((hours - h) * 60)
    return f"{h}h {m}m"

Q1 = data['Calories_Burned'].quantile(0.25)
Q3 = data['Calories_Burned'].quantile(0.75)
IQR = Q3 - Q1
data = data[~((data['Calories_Burned'] < (Q1 - 1.5 * IQR)) |
              (data['Calories_Burned'] > (Q3 + 1.5 * IQR)))]


data['Session_Duration_Format'] = data['Session_Duration (hours)'].apply(format_hours)
# Selecionando apenas algumas posições no eixo x
# Linspace - Números espaçados de forma uniforme em um intervalo especificado
x_ticks_positions = np.linspace(data['Session_Duration (hours)'].min(),
                                 data['Session_Duration (hours)'].max(),
                                 5)  # Reduzindo para 5 ticks

# Visualizações
plt.figure(figsize=(12, 6))
sns.histplot(data['Calories_Burned'], kde=True, bins=20, color='blue')
plt.title('Distribuição de Calorias Queimadas', fontsize=14)
plt.xlabel('Calorias Queimadas', fontsize=12)
plt.ylabel('Frequência', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

sns.boxplot(x=data['Calories_Burned'], color='orange')
plt.title('Boxplot de Calorias Queimadas')
plt.show()

x_ticks_labels = [format_hours(x) for x in x_ticks_positions]

sns.boxplot(x=data['Session_Duration (hours)'], color='yellow')
plt.title('Boxplot de Duração do Treino')
plt.xlabel('Duração do Treino (horas)', fontsize=12)
plt.ylabel('Calorias Queimadas', fontsize=12)

# Atualizando os ticks do eixo x
plt.xticks(ticks=x_ticks_positions, labels=x_ticks_labels, rotation=45)

plt.grid(axis='both', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()


plt.figure(figsize=(10, 6))
sns.regplot(x=data['Session_Duration (hours)'], y=data['Calories_Burned'], color='green', line_kws={'color': 'red'})
plt.title('Duração do Treino vs Calorias Queimadas', fontsize=14)
plt.xlabel('Duração do Treino (horas)', fontsize=12)
plt.ylabel('Calorias Queimadas', fontsize=12)

# Atualizando os ticks do eixo x
plt.xticks(ticks=x_ticks_positions, labels=x_ticks_labels, rotation=45)

plt.grid(axis='both', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

data = data.drop('Session_Duration_Format', axis=1)

X = data.drop('Calories_Burned', axis=1)
y = data['Calories_Burned']

# Escalonamento
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

elastic_net = ElasticNet(alpha=0.1)
elastic_net.fit(X_scaled, y)

feature_importance = pd.Series(elastic_net.coef_, index=X.columns)
print("Importância das variáveis:\n", feature_importance.sort_values(ascending=False))

data['Calorias_Categoria'] = pd.cut(data['Calories_Burned'], bins=3, labels=['Baixa', 'Média', 'Alta'])

X_train, X_test, y_train, y_test = train_test_split(X_scaled, data['Calorias_Categoria'], test_size=0.2, random_state=42)

# Modelo de classificação
log_model = LogisticRegression()
log_model.fit(X_train, y_train)

y_pred = log_model.predict(X_test)
print("Relatório de Classificação:\n", classification_report(y_test, y_pred))

conf_matrix = confusion_matrix(y_test, y_pred, labels=['Baixa', 'Média', 'Alta'])
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['Baixa', 'Média', 'Alta'],
            yticklabels=['Baixa', 'Média', 'Alta'])
plt.title('Matriz de Confusão (Classificação)', fontsize=14)
plt.xlabel('Previsão', fontsize=12)
plt.ylabel('Verdadeiro', fontsize=12)
plt.show()

person_predict = pd.read_csv("predict.csv")

scaler = StandardScaler()
predict_person = scaler.fit_transform(person_predict)
predict_person = scaler.transform(person_predict)

# Previsão da classificação
previsoes = log_model.predict(predict_person)

# Exibição dos resultados
for i, (previsao) in enumerate(previsoes):
    print(f"Dados {i+1}:")
    print(f" - Classificação prevista: {previsao}")

from collections import Counter

# Contando as ocorrências de cada categoria
contagem = Counter(previsoes)

# Separando as categorias e os valores
categorias = list(contagem.keys())
valores = list(contagem.values())

# Criando o gráfico de barras
plt.figure(figsize=(8, 5))
plt.bar(categorias, valores, color='skyblue')
plt.title('Frequência de Previsões', fontsize=14)
plt.xlabel('Classificação', fontsize=12)
plt.ylabel('Frequência', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()

# Exibir o gráfico
plt.show()